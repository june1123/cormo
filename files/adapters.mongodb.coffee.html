<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>CORMO - adapters/mongodb.coffee</title><script>if (location.protocol.match(/^http/) && location.pathname.match('\.html') === null && location.pathname.slice(-1) !== '/') {
  location.href = location.href + '/';
}</script><link href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet" type="text/css"><link href="../google-code-prettify/prettify.css" rel="stylesheet" type="text/css"><link href="../style.css" rel="stylesheet" type="text/css"></head><body data-spy="scroll" data-target=".sidebar"><div class="navbar navbar-default navbar-fixed-top"><div class="container-fluid"><ul class="nav navbar-nav"><li><a href="../index.html">Home</a></li><li class="dropdown"><a data-toggle="dropdown" href="#" class="dropdown-toggle">Guides <span class="caret"></span></a><ul class="dropdown-menu"><li><a href="../guides/Association.html">Association</a></li><li><a href="../guides/CLI.html">CLI</a></li><li><a href="../guides/Callback.html">Callback</a></li><li><a href="../guides/Constraint.html">Constraint</a></li><li><a href="../guides/CreateRecords.html">CreateRecords</a></li><li><a href="../guides/DefineModels.html">DefineModels</a></li><li><a href="../guides/Geospatial.html">Geospatial</a></li><li><a href="../guides/Miscellaneous.html">Miscellaneous</a></li><li><a href="../guides/Query.html">Query</a></li><li><a href="../guides/Validation.html">Validation</a></li></ul></li><li><a href="../modules/cormo.html">Modules</a></li><li><a href="../classes/ColumnProperty.html">Classes</a></li><li class="dropdown active"><a data-toggle="dropdown" href="#" class="dropdown-toggle">Files - adapters/mongodb.coffee <span class="caret"></span></a><ul class="dropdown-menu"><li><a href="../files/command.coffee.html">command.coffee</a></li><li><a href="../files/connection.coffee.html">connection.coffee</a></li><li><a href="../files/console.coffee.html">console.coffee</a></li><li><a href="../files/index.coffee.html">index.coffee</a></li><li><a href="../files/inflector.coffee.html">inflector.coffee</a></li><li><a href="../files/model.coffee.html">model.coffee</a></li><li><a href="../files/query.coffee.html">query.coffee</a></li><li><a href="../files/types.coffee.html">types.coffee</a></li><li><a href="../files/util.coffee.html">util.coffee</a></li><li><a href="../files/adapters.base.coffee.html">adapters/base.coffee</a></li><li><a href="../files/adapters.mongodb.coffee.html">adapters/mongodb.coffee</a></li><li><a href="../files/adapters.mysql.coffee.html">adapters/mysql.coffee</a></li><li><a href="../files/adapters.postgresql.coffee.html">adapters/postgresql.coffee</a></li><li><a href="../files/adapters.redis.coffee.html">adapters/redis.coffee</a></li><li><a href="../files/adapters.sql_base.coffee.html">adapters/sql_base.coffee</a></li><li><a href="../files/adapters.sqlite3.coffee.html">adapters/sqlite3.coffee</a></li><li><a href="../files/adapters.sqlite3_memory.coffee.html">adapters/sqlite3_memory.coffee</a></li><li><a href="../files/command.console.coffee.html">command/console.coffee</a></li><li><a href="../files/connection.association.coffee.html">connection/association.coffee</a></li><li><a href="../files/connection.manipulate.coffee.html">connection/manipulate.coffee</a></li><li><a href="../files/model.cache.coffee.html">model/cache.coffee</a></li><li><a href="../files/model.callback.coffee.html">model/callback.coffee</a></li><li><a href="../files/model.persistence.coffee.html">model/persistence.coffee</a></li><li><a href="../files/model.query.coffee.html">model/query.coffee</a></li><li><a href="../files/model.timestamp.coffee.html">model/timestamp.coffee</a></li><li><a href="../files/model.validate.coffee.html">model/validate.coffee</a></li></ul></li></ul><div class="options"><label class="checkbox"><input id="options-private" type="checkbox"> Private </label></div></div></div><div class="container-fluid content"><div class="row"><div data-spy="affix" class="hidden-xs sidebar col-sm-3"><div class="cormo-sidenav"><div class="panel panel-default"><div id="undefined_body" class="panel-collapse collapse in"><ul class="nav nav-pills nav-stacked"><li><a href="../files/command.coffee.html">command.coffee</a></li><li><a href="../files/connection.coffee.html">connection.coffee</a></li><li><a href="../files/console.coffee.html">console.coffee</a></li><li><a href="../files/index.coffee.html">index.coffee</a></li><li><a href="../files/inflector.coffee.html">inflector.coffee</a></li><li><a href="../files/model.coffee.html">model.coffee</a></li><li><a href="../files/query.coffee.html">query.coffee</a></li><li><a href="../files/types.coffee.html">types.coffee</a></li><li><a href="../files/util.coffee.html">util.coffee</a></li></ul></div></div><div class="panel panel-default"><div data-toggle="collapse" data-target="#adapters/_body" class="panel-heading">adapters/<span class="pull-right glyphicon"></span></div><div id="adapters/_body" class="panel-collapse collapse in"><ul class="nav nav-pills nav-stacked"><li><a href="../files/adapters.base.coffee.html">base.coffee</a></li><li class="active"><a href="../files/adapters.mongodb.coffee.html">mongodb.coffee</a></li><li><a href="../files/adapters.mysql.coffee.html">mysql.coffee</a></li><li><a href="../files/adapters.postgresql.coffee.html">postgresql.coffee</a></li><li><a href="../files/adapters.redis.coffee.html">redis.coffee</a></li><li><a href="../files/adapters.sql_base.coffee.html">sql_base.coffee</a></li><li><a href="../files/adapters.sqlite3.coffee.html">sqlite3.coffee</a></li><li><a href="../files/adapters.sqlite3_memory.coffee.html">sqlite3_memory.coffee</a></li></ul></div></div><div class="panel panel-default"><div data-toggle="collapse" data-target="#command/_body" class="panel-heading">command/<span class="pull-right glyphicon"></span></div><div id="command/_body" class="panel-collapse collapse in"><ul class="nav nav-pills nav-stacked"><li><a href="../files/command.console.coffee.html">console.coffee</a></li></ul></div></div><div class="panel panel-default"><div data-toggle="collapse" data-target="#connection/_body" class="panel-heading">connection/<span class="pull-right glyphicon"></span></div><div id="connection/_body" class="panel-collapse collapse in"><ul class="nav nav-pills nav-stacked"><li><a href="../files/connection.association.coffee.html">association.coffee</a></li><li><a href="../files/connection.manipulate.coffee.html">manipulate.coffee</a></li></ul></div></div><div class="panel panel-default"><div data-toggle="collapse" data-target="#model/_body" class="panel-heading">model/<span class="pull-right glyphicon"></span></div><div id="model/_body" class="panel-collapse collapse in"><ul class="nav nav-pills nav-stacked"><li><a href="../files/model.cache.coffee.html">cache.coffee</a></li><li><a href="../files/model.callback.coffee.html">callback.coffee</a></li><li><a href="../files/model.persistence.coffee.html">persistence.coffee</a></li><li><a href="../files/model.query.coffee.html">query.coffee</a></li><li><a href="../files/model.timestamp.coffee.html">timestamp.coffee</a></li><li><a href="../files/model.validate.coffee.html">validate.coffee</a></li></ul></div></div></div></div><div class="col-sm-9 col-sm-offset-3"><section><h1>adapters/mongodb.coffee</h1></section><pre class="prettyprint">try
  mongodb = require 'mongodb'
catch error
  console.log 'Install mongodb module to use this adapter'
  process.exit 1

ObjectID = mongodb.ObjectID

_ = require 'underscore'
AdapterBase = require './base'
async = require 'async'
types = require '../types'

_convertValueToObjectID = (value, key) -&gt;
  try
    new ObjectID value
  catch e
    throw new Error(&quot;'#{key}' is not a valid id&quot;)
# speed up version, doesn't work with native_parser
#  if value?
#    len = value.length
#    if len is 24
#      oid = ''
#      number = parseInt(value.substr(0, 2), 16)
#      oid += String.fromCharCode number if number&gt;=0 and number&lt;256
#      number = parseInt(value.substr(2, 2), 16)
#      oid += String.fromCharCode number if number&gt;=0 and number&lt;256
#      number = parseInt(value.substr(4, 2), 16)
#      oid += String.fromCharCode number if number&gt;=0 and number&lt;256
#      number = parseInt(value.substr(6, 2), 16)
#      oid += String.fromCharCode number if number&gt;=0 and number&lt;256
#      number = parseInt(value.substr(8, 2), 16)
#      oid += String.fromCharCode number if number&gt;=0 and number&lt;256
#      number = parseInt(value.substr(10, 2), 16)
#      oid += String.fromCharCode number if number&gt;=0 and number&lt;256
#      number = parseInt(value.substr(12, 2), 16)
#      oid += String.fromCharCode number if number&gt;=0 and number&lt;256
#      number = parseInt(value.substr(14, 2), 16)
#      oid += String.fromCharCode number if number&gt;=0 and number&lt;256
#      number = parseInt(value.substr(16, 2), 16)
#      oid += String.fromCharCode number if number&gt;=0 and number&lt;256
#      number = parseInt(value.substr(18, 2), 16)
#      oid += String.fromCharCode number if number&gt;=0 and number&lt;256
#      number = parseInt(value.substr(20, 2), 16)
#      oid += String.fromCharCode number if number&gt;=0 and number&lt;256
#      number = parseInt(value.substr(22, 2), 16)
#      oid += String.fromCharCode number if number&gt;=0 and number&lt;256
#      if oid.length is 12
#        return _bsontype: 'ObjectID', id: oid, toString: (-&gt; value), toJSON: (-&gt; value)
#  throw new Error(&quot;'#{key}' is not a valid id&quot;)

_objectIdToString = (oid) -&gt;
  oid = oid.id
  str = ''
  value = oid.charCodeAt 0
  str += '0' if value &lt; 16
  str += value.toString(16)
  value = oid.charCodeAt 1
  str += '0' if value &lt; 16
  str += value.toString(16)
  value = oid.charCodeAt 2
  str += '0' if value &lt; 16
  str += value.toString(16)
  value = oid.charCodeAt 3
  str += '0' if value &lt; 16
  str += value.toString(16)
  value = oid.charCodeAt 4
  str += '0' if value &lt; 16
  str += value.toString(16)
  value = oid.charCodeAt 5
  str += '0' if value &lt; 16
  str += value.toString(16)
  value = oid.charCodeAt 6
  str += '0' if value &lt; 16
  str += value.toString(16)
  value = oid.charCodeAt 7
  str += '0' if value &lt; 16
  str += value.toString(16)
  value = oid.charCodeAt 8
  str += '0' if value &lt; 16
  str += value.toString(16)
  value = oid.charCodeAt 9
  str += '0' if value &lt; 16
  str += value.toString(16)
  value = oid.charCodeAt 10
  str += '0' if value &lt; 16
  str += value.toString(16)
  value = oid.charCodeAt 11
  str += '0' if value &lt; 16
  str += value.toString(16)
  return str

_buildWhereSingle = (property, key, value, not_op) -&gt;
  if key isnt 'id' and not property?
    throw new Error(&quot;unknown column '#{key}'&quot;)
  property_type = property?.type
  is_objectid = key is 'id' or property_type is 'objectid'
  if Array.isArray value
    if is_objectid
      value = value.map (v) -&gt; _convertValueToObjectID v, key
    if not_op
      value = $nin: value
    else
      value = $in: value
  else if typeof value is 'object' and value isnt null and (keys = Object.keys value).length is 1
    sub_key = keys[0]
    switch sub_key
      when '$not'
        return _buildWhereSingle property, key, value[sub_key], not not_op
      when '$gt', '$lt', '$gte', '$lte'
        sub_value = value[sub_key]
        if is_objectid
          sub_value = _convertValueToObjectID sub_value, key
        else if property_type is types.Date
          sub_value = new Date sub_value
        value = {}
        value[sub_key] = sub_value
        if not_op
          value = $not: value
        obj = {}
        key = '_id' if key is 'id'
        obj[key] = value
        return obj
      when '$contains'
        value = new RegExp value[sub_key], 'i'
      when '$in'
        if is_objectid
          value[sub_key] = value[sub_key].map (v) -&gt; _convertValueToObjectID v, key
      else
        throw new Error &quot;unknown operator '#{sub_key}'&quot;
    if not_op
      value = $not: value
  else
    if is_objectid and value?
      value = _convertValueToObjectID value, key
    if not_op
      value = $ne: value

  obj = {}
  key = '_id' if key is 'id'
  value = new Date value if property_type is types.Date
  obj[key] = value
  return obj

_buildWhere = (schema, conditions, conjunction='$and') -&gt;
  if Array.isArray conditions
    subs = conditions.map (condition) -&gt; _buildWhere schema, condition
  else if typeof conditions is 'object'
    keys = Object.keys conditions
    if keys.length is 0
      return
    else if keys.length is 1
      key = keys[0]
      if key.substr(0, 1) is '$'
        switch key
          when '$and'
            return _buildWhere schema, conditions[key], '$and'
          when '$or'
            return _buildWhere schema, conditions[key], '$or'
        return
      else
        return _buildWhereSingle schema[key], key, conditions[key]
    else
      subs = keys.map (key) -&gt; _buildWhereSingle schema[key], key, conditions[key]
  else
    throw new Error &quot;'#{JSON.stringify conditions}' is not an object&quot;

  if subs.length is 0
    return
  else if subs.length is 1
    return subs[0]
  else
    if conjunction is '$and'
      before_count = _.reduce subs, ( (memo, sub) -&gt; memo + Object.keys(sub).length ), 0
      subs.unshift {}
      obj = _.extend.apply _, subs
      subs.shift()
      keys = Object.keys obj
      after_count = keys.length
      if before_count is after_count and not _.some(keys, (key) -&gt; key.substr(0, 1) is '$')
        return obj
    obj = {}
    obj[conjunction] = subs
    return obj

_buildGroupFields = (group_by, group_fields) -&gt;
  group = {}
  if group_by
    if group_by.length is 1
      group._id = '$' + group_by[0]
    else
      group._id = {}
      group_by.forEach (field) -&gt; group._id[field] = '$' + field
  else
    group._id = null
  for field, expr of group_fields
    group[field] = expr
  return group

##
# Adapter for MongoDB
# @namespace adapter
class MongoDBAdapter extends AdapterBase
  key_type: types.String
  key_type_internal: 'objectid'
  support_geopoint: true
  support_nested: true

  ##
  # Creates a MongoDB adapter
  constructor: (connection) -&gt;
    @_connection = connection
    @_collections = {}

  _getMongoDBColName = (name) -&gt;
    # there is a problem with name begins with underscore
    if name is '_archives'
      '@archives'
    else
      name

  _collection: (model) -&gt;
    name = @_connection.models[model].tableName
    if not @_collections[name]
      return @_collections[name] = new mongodb.Collection @_client, _getMongoDBColName name
    else
      return @_collections[name]

  ## @override AdapterBase::applySchema
  applySchema: (model, callback) -&gt;
    collection = @_collection(model)
    indexes = []
    for column, property of @_connection.models[model]._schema
      if property.unique
        if property.required
          indexes.push [ column, { unique: true } ]
        else
          indexes.push [ column, { unique: true, sparse: true } ]
      if property.type is types.GeoPoint
        obj = {}
        obj[column] = '2d'
        indexes.push [ obj ]
    for index in @_connection.models[model]._indexes
      if index.options.unique
        indexes.push [ index.columns, { name: index.options.name, unique: true, sparse: true } ]
      else
        indexes.push [ index.columns, { name: index.options.name } ]
    async.forEach indexes, (index, callback) -&gt;
      collection.ensureIndex index[0], index[1], (error) -&gt;
        callback error
    , (error) -&gt;
      callback error

  ## @override AdapterBase::drop
  drop: (model, callback) -&gt;
    name = @_connection.models[model].tableName
    delete @_collections[name]
    @_client.dropCollection _getMongoDBColName(name), (error) -&gt;
      # ignore not found error
      if error and error.errmsg isnt 'ns not found'
        return callback MongoDBAdapter.wrapError 'unknown error', error
      callback null

  idToDB: (value) -&gt;
    _convertValueToObjectID value, 'id'

  valueToDB: (value, column, property) -&gt;
    return if not value?
    # convert id type
    if column is 'id' or property.type is 'objectid'
      if property.array
        return value.map (v) -&gt; v and _convertValueToObjectID v, column
      else
        return _convertValueToObjectID value, column
    return value

  _getModelID: (data) -&gt;
    _objectIdToString data._id

  valueToModel: (value, property) -&gt;
    if property.type is 'objectid'
      if property.array
        value.map (v) -&gt; v and _objectIdToString v
      else
        value and _objectIdToString value
    else
      value

  ## @override AdapterBase::create
  create: (model, data, callback) -&gt;
    @_collection(model).insert data, safe: true, (error, result) -&gt;
      if error?.code is 11000
        column = ''
        key = error.err.match /index: [\w-.]+\$(\w+)/
        if key?
          column = key[1]
          key = column.match /(\w+)_1/
          if key?
            column = key[1]
          column = ' ' + column
        return callback new Error('duplicated' + column)
      return callback MongoDBAdapter.wrapError 'unknown error', error if error
      id = _objectIdToString result?[0]?._id
      if id
        delete data._id
        callback null, id
      else
        callback new Error 'unexpected result'

  ## @override AdapterBase::create
  createBulk: (model, data, callback) -&gt;
    @_collection(model).insert data, safe: true, (error, result) -&gt;
      if error?.code is 11000
        key = error.err.match /index: [\w-.]+\$(\w+)_1/
        return callback new Error('duplicated ' + key?[1])
      return callback MongoDBAdapter.wrapError 'unknown error', error if error
      error = undefined
      ids = result.map (doc) -&gt;
        id = _objectIdToString doc._id
        if id
          delete data._id
        else
          error = new Error 'unexpected result'
        return id
      return callback error if error
      callback null, ids

  ## @override AdapterBase::update
  update: (model, data, callback) -&gt;
    id = data.id
    delete data.id
    @_collection(model).update { _id: id }, data, safe: true, (error) -&gt;
      if error?.code is 11001
        key = error.err.match /index: [\w-.]+\$(\w+)_1/
        return callback new Error('duplicated ' + key?[1])
      return callback MongoDBAdapter.wrapError 'unknown error', error if error
      callback null

  _buildUpdateOps: (schema, update_ops, data, path, object) -&gt;
    for column, value of object
      property = schema[path+column]
      if property
        if value?
          update_ops.$set[path+column] = value
        else
          update_ops.$unset[path+column] = ''
      else if typeof object[column] is 'object'
        @_buildUpdateOps schema, update_ops, data, path + column + '.', object[column]

  ## @override AdapterBase::updatePartial
  updatePartial: (model, data, conditions, options, callback) -&gt;
    schema = @_connection.models[model]._schema
    try
      conditions = _buildWhere schema, conditions
    catch e
      return callback e
    if not conditions
      conditions = {}
    update_ops = $set: {}, $unset: {}
    @_buildUpdateOps schema, update_ops, data, '', data
    @_collection(model).update conditions, update_ops, safe: true, multi: true, (error, count) -&gt;
      if error?.code is 11001
        key = error.err.match /index: [\w-.]+\$(\w+)_1/
        return callback new Error('duplicated ' + key?[1])
      return callback MongoDBAdapter.wrapError 'unknown error', error if error
      callback null, count

  ## @override AdapterBase::findById
  findById: (model, id, options, callback) -&gt;
    if options.select
      fields = {}
      options.select.forEach (column) -&gt; fields[column] = 1
    try
      id = _convertValueToObjectID id, 'id'
    catch e
      return callback new Error('not found')
    client_options = {}
    if fields
      client_options.fields = fields
    @_collection(model).findOne _id: id, client_options, (error, result) =&gt;
      return callback MongoDBAdapter.wrapError 'unknown error', error if error
      return callback new Error('not found') if not result
      if options.lean
        callback null, @_refineRawInstance model, result, options.select, options.select_raw
      else
        callback null, @_convertToModelInstance model, result, options.select, options.select_raw

  ## @override AdapterBase::find
  find: (model, conditions, options, callback) -&gt;
    if options.select
      fields = {}
      options.select.forEach (column) -&gt; fields[column] = 1
    try
      conditions = _buildWhere @_connection.models[model]._schema, conditions
    catch e
      return callback e
    if options.near? and field = Object.keys(options.near)[0]
      # MongoDB fails if $near is mixed with $and
      keys = Object.keys conditions if conditions
      if keys and (keys.length &gt; 1 or keys[0].substr(0, 1) isnt '$')
        conditions[field] = { $near: options.near[field] }
      else
        obj = {}
        obj[field] = { $near: options.near[field] }
        if conditions
          conditions = { $and : [  conditions, obj ] }
        else
          conditions = obj
    if options.orders.length &gt; 0
      orders = {}
      options.orders.forEach (order) -&gt;
        if order[0] is '-'
          column = order[1..]
          dir = -1
        else
          column = order
          dir = 1
        if options.group_by
          if options.group_by.length is 1
            column = '_id' if column is options.group_by[0]
          else
            column = '_id.'+column if options.group_by.indexOf(column)&gt;=0
        else
          if column is 'id'
            column = '_id'
        orders[column] = dir
    #console.log JSON.stringify conditions
    if options.group_by or options.group_fields
      pipeline = []
      if conditions
        pipeline.push $match: conditions
      pipeline.push $group: _buildGroupFields options.group_by, options.group_fields
      pipeline.push $sort: orders if orders
      if options.conditions_of_group.length &gt; 0
        pipeline.push $match: _buildWhere options.group_fields, options.conditions_of_group
      @_collection(model).aggregate pipeline, (error, result) =&gt;
        return callback MongoDBAdapter.wrapError 'unknown error', error if error
        callback null, result.map (record) =&gt;
          if options.group_by
            if options.group_by.length is 1
              record[options.group_by[0]] = record._id
            else
              record[group] = record._id[group] for group in options.group_by
          @_convertToGroupInstance model, record, options.group_by, options.group_fields
    else
      client_options =
        limit: options.limit
        skip: options.skip
      if fields
        client_options.fields = fields
      if orders
        client_options.sort = orders
      @_collection(model).find conditions, client_options, (error, cursor) =&gt;
        return callback MongoDBAdapter.wrapError 'unknown error', error if error or not cursor
        cursor.toArray (error, result) =&gt;
          return callback MongoDBAdapter.wrapError 'unknown error', error if error
          if options.lean
            callback null, result.map (record) =&gt; @_refineRawInstance model, record, options.select, options.select_raw
          else
            callback null, result.map (record) =&gt; @_convertToModelInstance model, record, options.select, options.select_raw

  ## @override AdapterBase::count
  count: (model, conditions, callback) -&gt;
    try
      conditions = _buildWhere @_connection.models[model]._schema, conditions
    catch e
      return callback e
    #console.log JSON.stringify conditions
    @_collection(model).count conditions, (error, count) =&gt;
      return callback MongoDBAdapter.wrapError 'unknown error', error if error
      callback null, count

  ## @override AdapterBase::delete
  delete: (model, conditions, callback) -&gt;
    model_class = @_connection.models[model]
    try
      conditions = _buildWhere model_class._schema, conditions
    catch e
      return callback e
    #console.log JSON.stringify conditions
    @_collection(model).remove conditions, safe: true, (error, count) -&gt;
      return callback MongoDBAdapter.wrapError 'unknown error', error if error
      callback null, count

  ##
  # Connects to the database
  # @param {Object} settings
  # @param {String} [settings.host='localhost']
  # @param {Number} [settings.port=27017]
  # @param {String} [settings.user]
  # @param {String} [settings.password]
  # @param {String} settings.database
  # @nodejscallback
  connect: (settings, callback) -&gt;
    if settings.user or settings.password
      url = &quot;mongodb://#{settings.user}:#{settings.password}@#{settings.host or 'localhost'}:#{settings.port or 27017}/#{settings.database}&quot;
    else
      url = &quot;mongodb://#{settings.host or 'localhost'}:#{settings.port or 27017}/#{settings.database}&quot;
    mongodb.MongoClient.connect url, (error, db) =&gt;
      return callback MongoDBAdapter.wrapError 'unknown error', error if error
      @_client = db
      callback null

  ## @override AdapterBase::close
  close: -&gt;
    if @_client
      @_client.close()
    @_client = null

module.exports = (connection) -&gt;
  new MongoDBAdapter connection</pre></div></div></div><script src="http://code.jquery.com/jquery-1.11.0.min.js"></script><script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script><script src="../google-code-prettify/prettify.js"></script><script src="../script.js"></script><a href="https://github.com/croquiscom/cormo"><img src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" alt="Fork me on GitHub" class="github-ribbon"></a></body></html>